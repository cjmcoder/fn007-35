// FLOCKNODE Test Database Schema (SQLite compatible)
// Simplified version for local testing

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// =============================================================================
// USER MANAGEMENT
// =============================================================================

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  username    String   @unique
  displayName String
  avatarUrl   String?
  roles       String   @default("user")
  trustScore  Float    @default(100.0)
  tfaEnabled  Boolean  @default(false)
  tfaSecret   String?
  isBanned    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastLoginAt DateTime?

  // Relations
  profile     Profile?
  wallet      Wallet?
  authProviders AuthProvider[]
  refreshTokens RefreshToken[]
  matchesHost Match[] @relation("MatchHost")
  matchesOpponent Match[] @relation("MatchOpponent")
  transactions FcTransaction[]

  @@map("users")
}

model Profile {
  id          String   @id @default(cuid())
  userId      String   @unique
  bio         String?
  location    String?
  timezone    String?
  preferences String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model AuthProvider {
  id          String   @id @default(cuid())
  userId      String
  provider    String   // 'google', 'twitch', 'discord'
  providerId  String
  accessToken String?
  refreshToken String?
  expiresAt   DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@map("auth_providers")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

// =============================================================================
// WALLET SYSTEM
// =============================================================================

model Wallet {
  id              String   @id @default(cuid())
  userId          String   @unique
  availableFc     Float    @default(0.0)
  lockedFc        Float    @default(0.0)
  totalDeposited  Float    @default(0.0)
  totalWithdrawn  Float    @default(0.0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions    FcTransaction[]

  @@map("wallets")
}

model FcTransaction {
  id              String   @id @default(cuid())
  userId          String
  walletId        String
  type            String   // 'DEPOSIT', 'WITHDRAWAL', 'TRANSFER', 'WAGER', 'WIN', 'LOSS', 'PLATFORM_FEE'
  state           String   // 'PENDING', 'COMPLETED', 'FAILED'
  amountFc        Float
  balanceAfterFc  Float?
  refType         String?  // 'PAYPAL_ORDER', 'MATCH', 'TRANSFER'
  refId           String?
  idempotencyKey  String?
  metadata        String?  // JSON string for SQLite compatibility
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet          Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@map("fc_transactions")
}

// =============================================================================
// MATCH SYSTEM - DUAL MODE (VERIFIED_STREAM + PRIVATE_SERVER)
// =============================================================================

model Match {
  id            String      @id @default(cuid())
  mode          String      // 'VERIFIED_STREAM' | 'PRIVATE_SERVER'
  hostId        String
  oppId         String?
  gameId        String
  rulesetId     String
  region        String?
  entryFc       Float
  rakePercent   Int         @default(10)
  state         String      @default("PENDING") // 'PENDING', 'READY_CHECK', 'ACTIVE', 'COMPLETE', 'DISPUTED', 'CANCELLED'
  startAt       DateTime?
  completeAt    DateTime?
  winnerId      String?
  checklist     String?     // JSON string for mode-specific checklist
  signals       String?     // JSON string for overlay signals
  serverId      String?     // link to external orchestrator/panel id
  serverInfo    String?     // JSON string for server details
  streamLinks   String?     // JSON string for StreamPair
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  host          User        @relation("MatchHost", fields: [hostId], references: [id], onDelete: Cascade)
  opponent      User?       @relation("MatchOpponent", fields: [oppId], references: [id], onDelete: Cascade)
  serverReservation ServerReservation?
  streamPair    StreamPair?
  disputes      Dispute[]
  proofs        Proof[]

  @@map("matches")
}

model StreamPair {
  id         String         @id @default(cuid())
  matchId    String         @unique
  p1Provider String?        // 'TWITCH' | 'YOUTUBE' | 'KICK'
  p1Channel  String?
  p2Provider String?        // 'TWITCH' | 'YOUTUBE' | 'KICK'
  p2Channel  String?
  liveOkP1   Boolean        @default(false)
  liveOkP2   Boolean        @default(false)
  titleOkP1  Boolean        @default(false)
  titleOkP2  Boolean        @default(false)
  bitrateP1  Int?
  bitrateP2  Int?
  fpsP1      Int?
  fpsP2      Int?
  updatedAt  DateTime       @updatedAt

  match      Match          @relation(fields: [matchId], references: [id], onDelete: Cascade)
  @@map("stream_pairs")
}

model ServerReservation {
  id            String   @id @default(cuid())
  matchId       String   @unique
  gameSlug      String
  pteroServerId String
  hostNode      String
  ip            String
  port          Int
  password      String?
  status        String   // RESERVED|STARTING|READY|ACTIVE|STOPPING|RELEASED|FAILED
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  match         Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)
  @@map("server_reservations")
}

model Proof {
  id            String      @id @default(cuid())
  matchId       String
  userId        String
  type          String      // 'screenshot', 'vod', 'admin_log'
  fileKey       String
  fileUrl       String?
  createdAt     DateTime    @default(now())

  // Relations
  match         Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@map("proofs")
}

model Dispute {
  id            String      @id @default(cuid())
  matchId       String
  openedBy      String      // userId who opened dispute
  reason        String
  notes         String?
  status        String      @default("OPEN") // OPEN, RESOLVED, CLOSED
  resolution    String?     // PAYOUT, REFUND, VOID
  resolvedBy    String?     // admin userId
  resolvedAt    DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  match         Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@map("disputes")
}

// =============================================================================
// AUDIT LOGGING
// =============================================================================

model AuditLog {
  id          String   @id @default(cuid())
  actorType   String   // 'USER', 'SYSTEM', 'ADMIN'
  actorId     String?
  action      String
  entityType  String
  entityId    String?
  meta        String?
  createdAt   DateTime @default(now())

  @@map("audit_logs")
}





